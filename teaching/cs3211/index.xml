<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS3211 Spring 2025 - T09 on Nicholas Yek</title><link>https://nichyjt.github.io/teaching/cs3211/</link><description>Recent content in CS3211 Spring 2025 - T09 on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Sat, 05 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/teaching/cs3211/index.xml" rel="self" type="application/rss+xml"/><item><title>BONUS: Borrowing Puzzles in Rust</title><link>https://nichyjt.github.io/teaching/cs3211/bonus_nll/</link><pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/bonus_nll/</guid><description>In class, we discussed about Rust&amp;rsquo;s shared-xor-mutable model.
You can only have either:
ONE mutable borrow Multiple immutable borrows There might be some common misconception if you are not aware of &amp;rsquo;non-lexical-lifetimes'.
Consider this:
0 1 2 3 let mut x = 1; let mut y = &amp;amp;mut x; let z = &amp;amp;x; x += 1 What will be the value of x?
A: 2
B: Compile error
C: Panics</description></item><item><title>Tutorial 2 QnA</title><link>https://nichyjt.github.io/teaching/cs3211/t2_faq/</link><pubDate>Thu, 27 Feb 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/t2_faq/</guid><description>Index Index Q1: synchronises-with if/while Optional Food for thought pop quiz: ambiguous sw Q1: synchronises-with if/while Tutorial 2, question 4.1. Just to clarify, if we remove the while loop and replaced it with an if-statement, it will also not synchronize with right?
The snippet in question is:
I&amp;rsquo;m assuming the question is asking if (b) sw (x) if we change while to if.
If we remove the while loop and replace it with an if-statement, you might get a synchronize-with, based on what (x) actually reads.</description></item><item><title>Tutorial 3 QnA</title><link>https://nichyjt.github.io/teaching/cs3211/t3_faq/</link><pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/t3_faq/</guid><description>Index Index Q1: synchronises-with is not symmetric Q2: When increments happen Addendum to 4.5 example Q3: Release Sequences Revisited Relaxed RMW cannot head release sequences Non RMW operations break release sequence chains Synchronises-with inside release sequences Q1: synchronises-with is not symmetric Is synchronized-with a symmetric relation? That is, if X synchronizes with Y, then does Y synchronize with X too? My guess is that it&amp;rsquo;s not, because for X to sync with Y, its release must be on the same memory location as Y&amp;rsquo;s acquire, so this relationship is inherently directed.</description></item><item><title>Tutorial 0 &amp; Tutorial 1 QnA</title><link>https://nichyjt.github.io/teaching/cs3211/t1_faq/</link><pubDate>Sun, 09 Feb 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/t1_faq/</guid><description>Index Index Q1: Different lock types Q2: Correction: std::move&amp;rsquo;s Unspecified State? Correction: moved thread is not joinable C++ Implementations of std::move affects its internal state Q3: Lambdas - why don&amp;rsquo;t we use the argument list () instead of capture lists []? Q4: Why do spurious wakeups happen? The simple answer: It is allowed by POSIX Not satisfied? Q1: Different lock types What&amp;rsquo;s the difference between lock_guard, scoped_lock and unique_lock? It seems like scoped_lock is similar lock_guard, but it can acquire multiple mutexes together, so is there a need to use lock_guard?</description></item><item><title>Lambdas (capture lists) Revisited</title><link>https://nichyjt.github.io/teaching/cs3211/lambdas_revisited/</link><pubDate>Sat, 08 Feb 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/lambdas_revisited/</guid><description>Caveat: You aren&amp;rsquo;t going to be tested on lambda capture lists (afaik), and you&amp;rsquo;d probably NOT use this syntax very much in your assignments.
However, lambdas were covered briefly during tutorial because you&amp;rsquo;d see many funky lambda declarations in the wild on StackOverflow while you are debugging (for your assignment). This is to help aid your understanding while reading concurrent c++ code in the real world.
There was some confusion to the behaviour of lambda capture list behaviour, so I will elaborate on them here.</description></item><item><title>The Most Vexing Parse rule</title><link>https://nichyjt.github.io/teaching/cs3211/vexing_parse/</link><pubDate>Wed, 05 Feb 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/vexing_parse/</guid><description>You have learnt in lecture that there are many ways to create threads, and certain ways of creating threads actually don&amp;rsquo;t work.
Due to time constraints + how confusing this may be, this isn&amp;rsquo;t covered in the tutorial.
A brief recap of what you see in lecture:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &amp;lt;iostream&amp;gt; #include &amp;lt;thread&amp;gt; void task(); // assume this is implemented class TaskClass { // callable type public: void operator()() const { task(); } }; int main() { std::thread t0(task); // my favorite style.</description></item></channel></rss>