<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS3211 Spring 2025 - T09 on Nicholas Yek</title><link>https://nichyjt.github.io/teaching/cs3211/</link><description>Recent content in CS3211 Spring 2025 - T09 on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Sat, 08 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/teaching/cs3211/index.xml" rel="self" type="application/rss+xml"/><item><title>Lambdas (capture lists) Revisited</title><link>https://nichyjt.github.io/teaching/cs3211/lambdas_revisited/</link><pubDate>Sat, 08 Feb 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/lambdas_revisited/</guid><description>Caveat: You aren&amp;rsquo;t going to be tested on lambda capture lists (afaik), and you&amp;rsquo;d probably NOT use this syntax very much in your assignments.
However, lambdas were covered briefly during tutorial because you&amp;rsquo;d see many funky lambda declarations in the wild on StackOverflow while you are debugging (for your assignment). This is to help aid your understanding while reading concurrent c++ code in the real world.
There was some confusion to the behaviour of lambda capture list behaviour, so I will elaborate on them here.</description></item><item><title>The Most Vexing Parse rule</title><link>https://nichyjt.github.io/teaching/cs3211/vexing_parse/</link><pubDate>Wed, 05 Feb 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/teaching/cs3211/vexing_parse/</guid><description>You have learnt in lecture that there are many ways to create threads, and certain ways of creating threads actually don&amp;rsquo;t work.
Due to time constraints + how confusing this may be, this isn&amp;rsquo;t covered in the tutorial.
A brief recap of what you see in lecture:
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &amp;lt;iostream&amp;gt;#include &amp;lt;thread&amp;gt; void task(); // assume this is implemented class TaskClass { // callable type public: void operator()() const { task(); } }; int main() { std::thread t0(task); // my favorite style.</description></item></channel></rss>