<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Essays on Nicholas Yek</title><link>https://nichyjt.github.io/essays/</link><description>Recent content in Essays on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Thu, 10 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/essays/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker is not a Virtual Machine</title><link>https://nichyjt.github.io/essays/2025/docker_and_vms/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2025/docker_and_vms/</guid><description>Docker is not a VM. Neither is it a lightweight VM. But what&amp;rsquo;s the difference? My dockerfile needs an image of an OS (e.g. Ubuntu) to run, and virtual machines (such as VirtualBox) requires an image of an OS to also run, and both produce similar runtime environments for me to run the code in. Don&amp;rsquo;t they do the same thing?
The difference is what resources they virtualize.
Hypervisors &amp;amp; Virtual Machines in 30s Hypervisors (Virtual Machine Managers) emulate hardware resources.</description></item><item><title>Yet another spinlock implementation</title><link>https://nichyjt.github.io/essays/2025/spinlock/</link><pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2025/spinlock/</guid><description>Another Spinlock Question Implementation Explanation Limitations &amp;amp; Discussion Another Spinlock Question This question is adapted from my year&amp;rsquo;s Advanced Operating Systems finals. I didn&amp;rsquo;t check the answer scheme / results for this, but I&amp;rsquo;m fairly confident this is somewhat correct. I&amp;rsquo;m writing this to scratch that concurrency itch.
Consider this atomic instruction: lock-xadd(), where it has the side effects of the following C code:
0 1 2 3 4 5 6 void lock_xadd(int *src, int *dst); // Atomically does the following { temp = *src + *dst; *src = *dst; *dst = temp; } Question: Implement spin_lock() and spin_unlock() in C using the lock_xadd() function.</description></item><item><title>Freedom enslaves</title><link>https://nichyjt.github.io/essays/2025/constraints/</link><pubDate>Fri, 30 May 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2025/constraints/</guid><description>Modern art tends to be shit, but this piece that I stumbled upon scratched an itch.
Art piece at Parkview hotel The art seems simple. Four humans dressed in prison clothes. They face a cage and are postured towards it. The prisoners are uncaged, free, liberated; yet it seems like they long for the cage. Huh? Why would the prisoners want to be caged?
Perhaps they aren&amp;rsquo;t actually free. If they were free, then they wouldn&amp;rsquo;t be facing the cage or walking towards it.</description></item><item><title>A simple Rust puzzle about borrow checking</title><link>https://nichyjt.github.io/essays/2025/rs_puzzle/</link><pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2025/rs_puzzle/</guid><description>Rust is a cool language. But a small misconception can happen due a misunderstanding of borrowing and scoping rules for the language. Let me illustrate.
For those unfamiliar, a big feature of Rust is its borrowing and ownership rules. The rules are quite elegant, and are enforced at compile-time with the compiler&amp;rsquo;s borrow checker to ensure memory safety. I will summarise the rules here briefly:
Rule 1, Ownership:
One and only one owner can exist for any data that is allocated.</description></item><item><title>MPMC Message Queue using only atomics</title><link>https://nichyjt.github.io/essays/2024/atomic-mq/</link><pubDate>Sun, 16 Jun 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2024/atomic-mq/</guid><description>The Code In memory limited environments, using typical C++ synchronization primitives such as counting_semaphores may not be possible. Or perhaps you are using C. So, a pure atomic implementation may be needed.
This is my crack at making a buffered MPMC MQ.
Done in 1 night as a POC to a peer. So, this is likely problematic somewhere. But for the sake of documentation, here it is.
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include &amp;lt;stdatomic.</description></item><item><title>Caching makes things fast - an embedded example (CG2271)</title><link>https://nichyjt.github.io/essays/2024/caching/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2024/caching/</guid><description>Caching things smartly can make systems efficient.
Embedded systems have limited resources. We need to carefully manage how messages are being sent and how we handle state changes.
In this writeup (and personal reflection), I highlight a real exampleBut greatly simplified &amp;#8203; to show how caching state can lead to performance gains.
Sending signals For some context, this (toy) example was from a Real-time Operating System (CG2271) course where we had to build a race car and complete an obstacle course in the fastest time possible.</description></item><item><title>Hotswapping kernels like they're keyboard switches</title><link>https://nichyjt.github.io/essays/2024/kernel_duckery/</link><pubDate>Sat, 20 Jan 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2024/kernel_duckery/</guid><description>New Kernels break things. Old Kernels break things. Sometimes in life you want to turn back time to simpler times.
I&amp;rsquo;m taking CS3211 and learning to use thread sanitizer (TSAN) to debug concurrent C++ programs.
Alas, FATAL: ThreadSanitizer: unexpected memory mapping 0x5fb3d2108000-0x5fb3d2129000
Even the simplest of &amp;ldquo;hello world&amp;rdquo; programs (with no concurrency) results in a crash. Pain.
After hours of google-fu, prowling old-school forums and asking around, it turns out to be a kernel issue.</description></item><item><title>Generalized CNF for "At Least k, given n variables"</title><link>https://nichyjt.github.io/essays/2023/atleastk/</link><pubDate>Thu, 28 Dec 2023 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2023/atleastk/</guid><description>I built this formula in preparation for CS3243 finals, but on hindsight it was overkill and the exam didn&amp;rsquo;t even need this&amp;hellip; üò¢
But, in the spirit of sharing, here&amp;rsquo;s my questionable formula and the method I obtained this.
General CNF at least k, n variables For $n$ variables, $X = \set{x_1, x_2, &amp;hellip;, x_n}$. Arrange them into combinations of k variables.
Denote the set of k-variable combinations, $C = \set{c_1, c_2, &amp;hellip;}$, or more formally in the following footnote^1.</description></item><item><title>Finding Big O from non-standard recurrence relations without master method</title><link>https://nichyjt.github.io/essays/2023/recurrence/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2023/recurrence/</guid><description>A friend taking their data structures and algorithms (DSA) class asked me a question about recurrence relations. Consider this:
$ \text{Find } O(T(n)), \text{where} ~ T(n) = 3T(\frac{2}{3}n) $
This was derived from pseudocode where 3 recursive calls are made per function call, each splitting the subproblem into (2/3) N.
Nevermind the practicality, its a DSA course after all.
It doesn&amp;rsquo;t fit any of the common recurrence relations. Tools like the master method are not taught at entry level DSA classes (or even bootcamps)!</description></item><item><title>Recovering Linux from initramfs</title><link>https://nichyjt.github.io/essays/2022/initramfs/</link><pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/initramfs/</guid><description>You turned on your Linux machine and are greeted by a very scary looking terminal. You&amp;rsquo;ve booted into busybox and are in initramfs. How do I fix this?
initramfs, Image src: askubuntu question Very rarely, memory can get corrupted on your Linux machine. When that happens, you boot into the terminal above. The fix is a simple 1 line command using the fsck built-in tool.
Before using fsck, you need to identify which hard disk stores your working data.</description></item><item><title>How to choose which OS to boot into with systemd-boot</title><link>https://nichyjt.github.io/essays/2022/popos_choose_os/</link><pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/popos_choose_os/</guid><description>You are a POP!_OS user or use systemd-boot, and want this screen to pop up when you boot.
systemd-boot menu, Image src: freedesktop.org This guide is for you.
POP_OS was not configured to have the boot menu come up so there is a bit of settings config required.
Option 1: Hold spacebar When you boot, hold spacebar and the menu should show up. Arrow keys to select your boot entry to and press enter to boot into it.</description></item><item><title>CG2111A - Mod Review</title><link>https://nichyjt.github.io/essays/2022/cg2111a/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/cg2111a/</guid><description>Engineering Principles and Practice 2 (EPP2) CG2111A, aka EPP2 is the highlight module for Computer Engineering freshies.
Personally, it&amp;rsquo;s one of my favourite modules of the semester despite the difficulty. You can expect to build interesting things and learn a whole range of computing topics.
I will be sharing my experience based on the AY 21/22 Semester 2 iteration.
Mapping the maze using Alex&amp;#39;s LiDAR ^ To reiterate, you&amp;rsquo;ll be building cool stuff :)</description></item><item><title>CG1111A - Mod Review</title><link>https://nichyjt.github.io/essays/2022/cg1111a/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/cg1111a/</guid><description>Engineering Principles and Practice 1 (EPP1) CG1111A, aka EPP1 is the very first CEG module NUS Computer Engineering students will be taking.
This is the highlight module for the semester (apart from CS1010), so look forward to it!
I will be sharing my experience based on the AY 21/22 Semester 1 iteration.
CG1111A is conducted in a flipped classroom format where content learning is done asynchronusly and the hands-on learning done via labs and tutorials.</description></item><item><title>Making Linux Home</title><link>https://nichyjt.github.io/essays/2021/linux/</link><pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2021/linux/</guid><description>Linux üêß - A Tasty Introduction Are you tired of having useless, suspicious üëÄ bloatware being installed on your computer?
Are you looking for a more secure and stable machine out-of-the-box?
Are you a developer that wants to be in better control of your machine?
Perhaps Linux is for you.
What&amp;rsquo;s Linux? Linux refers to the family of Operating Systems (OS) that use the open-source Linux kernel. It may seem like a niche OS, but Linux plays a much larger role in your daily life than you might expect.</description></item></channel></rss>