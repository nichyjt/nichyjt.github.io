<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Essays on Nicholas Yek</title><link>https://nichyjt.github.io/essays/</link><description>Recent content in Essays on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Thu, 01 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/essays/index.xml" rel="self" type="application/rss+xml"/><item><title>Caching makes things fast - an embedded case study in CG2271</title><link>https://nichyjt.github.io/essays/2023/caching/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2023/caching/</guid><description>Caching things smartly can make systems efficient.
Embedded systems have limited resources. We need to carefully manage how messages are being sent and how we handle state changes.
In this writeup (and personal reflection), I highlight a real example But greatly simplified to show how caching state can lead to performance gains.
Sending signals For some context, this (toy) example was from a Real-time Operating System (CG2271) course where we had to build a race car and complete an obstacle course in the fastest time possible.</description></item><item><title>Hotswapping kernels like they're keyboard switches</title><link>https://nichyjt.github.io/essays/2023/kernel_duckery/</link><pubDate>Sat, 20 Jan 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2023/kernel_duckery/</guid><description>New Kernels break things. Old Kernels break things. Sometimes in life you want to turn back time to simpler times.
I&amp;rsquo;m taking CS3211 and learning to use thread sanitizer (TSAN) to debug concurrent C++ programs.
Alas,
FATAL: ThreadSanitizer: unexpected memory mapping 0x5fb3d2108000-0x5fb3d2129000 Even the simplest of &amp;ldquo;hello world&amp;rdquo; programs (with no concurrency) results in a crash. Pain.
After hours of google-fu, prowling old-school forums and asking around, it turns out to be a kernel issue.</description></item><item><title>General CNF for "At Least k, given n variables" constraint</title><link>https://nichyjt.github.io/essays/2023/atleastk/</link><pubDate>Thu, 28 Dec 2023 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2023/atleastk/</guid><description>I built this formula in preparation for CS3243 finals, but on hindsight it was overkill and the exam didn&amp;rsquo;t even need this&amp;hellip; &amp;#x1f622;
But, in the spirit of sharing, here&amp;rsquo;s my questionable formula and the method I obtained this.
General CNF at least k, n variables For $n$ variables, $X = \set{x_1, x_2, &amp;hellip;, x_n}$. Arrange them into combinations of k variables.
Denote the set of k-variable combinations, $C = \set{c_1, c_2, &amp;hellip;}$, or more formally in the following footnote^1.</description></item><item><title>Finding Big O from non-standard recurrence relations without master method</title><link>https://nichyjt.github.io/essays/2023/recurrence/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2023/recurrence/</guid><description>A friend taking their data structures and algorithms (DSA) class asked me a question about recurrence relations. Consider this:
$ \text{Find } O(T(n)), \text{where} ~ T(n) = 3T(\frac{2}{3}n) $
This was derived from pseudocode where 3 recursive calls are made per function call, each splitting the subproblem into (2/3) N.
Nevermind the practicality, its a DSA course after all.
It doesn&amp;rsquo;t fit any of the common recurrence relations. Tools like the master method are not taught at entry level DSA classes (or even bootcamps)!</description></item><item><title>Recovering Linux from initramfs</title><link>https://nichyjt.github.io/essays/2022/initramfs/</link><pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/initramfs/</guid><description>You turned on your Linux machine and are greeted by a very scary looking terminal. You&amp;rsquo;ve booted into busybox and are in initramfs. How do I fix this?
initramfs, Image src: askubuntu question Very rarely, memory can get corrupted on your Linux machine. When that happens, you boot into the terminal above. The fix is a simple 1 line command using the fsck built-in tool.
Before using fsck, you need to identify which hard disk stores your working data.</description></item><item><title>How to choose which OS to boot into with systemd-boot</title><link>https://nichyjt.github.io/essays/2022/popos_choose_os/</link><pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/popos_choose_os/</guid><description>You are a POP!_OS user or use systemd-boot, and want this screen to pop up when you boot.
systemd-boot menu, Image src: freedesktop.org This guide is for you.
POP_OS was not configured to have the boot menu come up so there is a bit of settings config required.
Option 1: Hold spacebar When you boot, hold spacebar and the menu should show up. Arrow keys to select your boot entry to and press enter to boot into it.</description></item><item><title>CG2111A - Mod Review</title><link>https://nichyjt.github.io/essays/2022/cg2111a/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/cg2111a/</guid><description>Engineering Principles and Practice 2 (EPP2) CG2111A, aka EPP2 is the highlight module for Computer Engineering freshies.
Personally, it&amp;rsquo;s one of my favourite modules of the semester despite the difficulty. You can expect to build interesting things and learn a whole range of computing topics.
I will be sharing my experience based on the AY 21/22 Semester 2 iteration.
Mapping the maze using Alex&amp;#39;s LiDAR ^ To reiterate, you&amp;rsquo;ll be building cool stuff :)</description></item><item><title>CG1111A - Mod Review</title><link>https://nichyjt.github.io/essays/2022/cg1111a/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2022/cg1111a/</guid><description>Engineering Principles and Practice 1 (EPP1) CG1111A, aka EPP1 is the very first CEG module NUS Computer Engineering students will be taking.
This is the highlight module for the semester (apart from CS1010), so look forward to it!
I will be sharing my experience based on the AY 21/22 Semester 1 iteration.
CG1111A is conducted in a flipped classroom format where content learning is done asynchronusly and the hands-on learning done via labs and tutorials.</description></item><item><title>Making Linux Home</title><link>https://nichyjt.github.io/essays/2021/linux/</link><pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2021/linux/</guid><description>Linux &amp;#x1f427; - A Tasty Introduction Are you tired of having useless, suspicious &amp;#x1f440; bloatware being installed on your computer?
Are you looking for a more secure and stable machine out-of-the-box?
Are you a developer that wants to be in better control of your machine?
Perhaps Linux is for you.
What&amp;rsquo;s Linux? Linux refers to the family of Operating Systems (OS) that use the open-source Linux kernel. It may seem like a niche OS, but Linux plays a much larger role in your daily life than you might expect.</description></item></channel></rss>