<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C/C++ on Nicholas Yek</title><link>https://nichyjt.github.io/tags/c/c++/</link><description>Recent content in C/C++ on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Tue, 03 Jun 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/tags/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Yet another spinlock implementation</title><link>https://nichyjt.github.io/essays/2025/spinlock/</link><pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2025/spinlock/</guid><description>Another Spinlock Question Implementation Explanation Limitations &amp;amp; Discussion Another Spinlock Question This question is adapted from my year&amp;rsquo;s Advanced Operating Systems finals. I didn&amp;rsquo;t check the answer scheme / results for this, but I&amp;rsquo;m fairly confident this is somewhat correct. I&amp;rsquo;m writing this to scratch that concurrency itch.
Consider this atomic instruction: lock-xadd(), where it has the side effects of the following C code:
0 1 2 3 4 5 6 void lock_xadd(int *src, int *dst) { // Atomically does the following temp = *src + *dst; *src = *dst; *dst = temp; } Question: Implement spin_lock() and spin_unlock() in C using the lock_xadd() function.</description></item><item><title>MPMC Message Queue using only atomics</title><link>https://nichyjt.github.io/essays/2024/atomic-mq/</link><pubDate>Sun, 16 Jun 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2024/atomic-mq/</guid><description>The Code In memory limited environments, using typical C++ synchronization primitives such as counting_semaphores may not be possible. Or perhaps you are using C. So, a pure atomic implementation may be needed.
This is my crack at making a buffered MPMC MQ.
Done in 1 night as a POC to a peer. So, this is likely problematic somewhere. But for the sake of documentation, here it is.
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include &amp;lt;stdatomic.</description></item><item><title>SnipNScan :camera:</title><link>https://nichyjt.github.io/projects/snipnscan/</link><pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/projects/snipnscan/</guid><description>Image Hell A picture is worth a thousand words - A common adage
Images are a rich source of information. But what worth is that thousand words if I can&amp;rsquo;t extract the actual text inside the images? Let me explain my frustration about images.
Webinar Link Hell Imagine yourself in some online conference. Stare in wonder as the presenter asks you to access some (long-ass) link on their screen share. Extra points if the presenter does not drop the link into chat - good luck typing it into your browser before they move on!</description></item><item><title>Cnake :snake:</title><link>https://nichyjt.github.io/projects/cnake/</link><pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/projects/cnake/</guid><description>I thought it would be fun to make a one-shot snake game project to familiarise myself with the ncurses library and play around with some data structures, which led to this ripoff snake game you can find on my GitHub.
If you&amp;rsquo;re interested, you can take a look and perhaps give it a go!
The following sections of this post are just some code discussions for the nerds.
Building Cnake I won&amp;rsquo;t talk too much about the ncurses library and will be writing more about the things I found interesting while building this project, mainly, these questions I had to answer while making the game.</description></item></channel></rss>