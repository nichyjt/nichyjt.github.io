<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on Nicholas Yek</title><link>https://nichyjt.github.io/tags/rust/</link><description>Recent content in Rust on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Sat, 05 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>A simple Rust puzzle about borrow checking</title><link>https://nichyjt.github.io/essays/2025/rs_puzzle/</link><pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2025/rs_puzzle/</guid><description>Rust is a cool language. But a small misconception can happen due a misunderstanding of borrowing and scoping rules for the language. Let me illustrate.
For those unfamiliar, a big feature of Rust is its borrowing and ownership rules. The rules are quite elegant, and are enforced at compile-time with the compiler&amp;rsquo;s borrow checker to ensure memory safety. I will summarise the rules here briefly:
Rule 1, Ownership:
One and only one owner can exist for any data that is allocated.</description></item></channel></rss>