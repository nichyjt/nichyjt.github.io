<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RTOS on Nicholas Yek</title><link>https://nichyjt.github.io/tags/rtos/</link><description>Recent content in RTOS on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Thu, 01 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/tags/rtos/index.xml" rel="self" type="application/rss+xml"/><item><title>Caching makes things fast - an embedded case study in CG2271</title><link>https://nichyjt.github.io/essays/2024/caching/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2024/caching/</guid><description>Caching things smartly can make systems efficient.
Embedded systems have limited resources. We need to carefully manage how messages are being sent and how we handle state changes.
In this writeup (and personal reflection), I highlight a real example But greatly simplified &amp;nbsp; to show how caching state can lead to performance gains.
Sending signals For some context, this (toy) example was from a Real-time Operating System (CG2271) course where we had to build a race car and complete an obstacle course in the fastest time possible.</description></item></channel></rss>