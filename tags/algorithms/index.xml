<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Nicholas Yek</title><link>https://nichyjt.github.io/tags/algorithms/</link><description>Recent content in Algorithms on Nicholas Yek</description><generator>Hugo -- gohugo.io</generator><language>en-sg</language><copyright>Nicholas Yek</copyright><lastBuildDate>Thu, 01 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://nichyjt.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Caching makes things fast - an embedded example (CG2271)</title><link>https://nichyjt.github.io/essays/2024/caching/</link><pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2024/caching/</guid><description>Caching things smartly can make systems efficient.
Embedded systems have limited resources. We need to carefully manage how messages are being sent and how we handle state changes.
In this writeup (and personal reflection), I highlight a real exampleBut greatly simplified &amp;#8203; to show how caching state can lead to performance gains.
Sending signals For some context, this (toy) example was from a Real-time Operating System (CG2271) course where we had to build a race car and complete an obstacle course in the fastest time possible.</description></item><item><title>Finding Big O from non-standard recurrence relations without master method</title><link>https://nichyjt.github.io/essays/2023/recurrence/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><guid>https://nichyjt.github.io/essays/2023/recurrence/</guid><description>A friend taking their data structures and algorithms (DSA) class asked me a question about recurrence relations. Consider this:
$ \text{Find } O(T(n)), \text{where} ~ T(n) = 3T(\frac{2}{3}n) $
This was derived from pseudocode where 3 recursive calls are made per function call, each splitting the subproblem into (2/3) N.
Nevermind the practicality, its a DSA course after all.
It doesn&amp;rsquo;t fit any of the common recurrence relations. Tools like the master method are not taught at entry level DSA classes (or even bootcamps)!</description></item><item><title>Sudoku.py</title><link>https://nichyjt.github.io/projects/sudoku/</link><pubDate>Sun, 30 May 2021 21:08:04 +0800</pubDate><guid>https://nichyjt.github.io/projects/sudoku/</guid><description>Sudoku Squares are elegant, and frankly, magical.1 With pockets of time being freed up with work from home orders during the COVID-19 pandemic, I picked up Sudoku to fill in the gaps. And man, it&amp;rsquo;s fun solving them - it&amp;rsquo;s cathartic seeing the numbers fall nicely into place.
It&amp;rsquo;s one thing to solve Sudokus, but another to create one.
Out of curiosity, I decided to try and make a fully filled Sudoku Grid by hand.</description></item></channel></rss>